/* =======================================================
   challenge.js — Dynamic Window Manager (DWM) + utilities
   ======================================================= */

/* ----------------------
   Clock (unchanged)
   ---------------------- */
function updateClock() {
    const now = new Date();
    const el = document.getElementById("clock");
    if (el) el.textContent = now.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
}
setInterval(updateClock, 1000);
window.onload = updateClock;

/* =======================================================
   DWM: window registry, layering, spawn/focus/minimize/maximize
   ======================================================= */
const DWM = (function() {
    const windows = {};            // id -> window meta {el, id, type, minimized}
    let zBase = 100;               // base z-index for windows
    let zCounter = zBase;          // increment when bringing to front
    let uidCounter = 1;            // for autogenerated ids
    const windowsRoot = () => document.getElementById('windows-root');

    // helper: generate unique id
    function genId(prefix='win') {
        uidCounter += 1;
        return `${prefix}-${Date.now().toString(36)}-${uidCounter}`;
    }

    // bring a window to front and focus it (set z-index)
    function bringToFront(winEl) {
        if (!winEl) return;
        zCounter++;
        winEl.style.zIndex = zCounter;
        // mark focused styling
        document.querySelectorAll('.c-window').forEach(w => w.classList.remove('window-focused'));
        winEl.classList.add('window-focused');
    }

    // create window DOM element for a given type
    function createWindowElement(type, opts = {}) {
        const id = opts.id || genId(type);
        const title = opts.title || (type === 'terminal' ? 'Terminal' : (opts.title || 'Window'));
        const width = opts.width || 600;
        const height = opts.height || 380;
        const left = opts.left !== undefined ? opts.left : 120 + (Object.keys(windows).length * 24);
        const top = opts.top !== undefined ? opts.top : 80 + (Object.keys(windows).length * 24);

        // construct DOM element
        const wrapper = document.createElement('div');
        wrapper.className = 'c-window';
        wrapper.id = id;
        wrapper.style.position = 'absolute';
        wrapper.style.left = `${left}px`;
        wrapper.style.top = `${top}px`;
        wrapper.style.width = `${width}px`;
        wrapper.style.height = `${height}px`;
        wrapper.style.zIndex = ++zCounter;

        // header
        wrapper.innerHTML = `
            <div class="c-window-header window-header">
                <div class="win-controls">
                    <button class="win-btn win-min" title="Minimize">–</button>
                    <button class="win-btn win-max" title="Maximize">☐</button>
                    <button class="win-btn win-close" title="Close">×</button>
                </div>
                <span class="window-title">${escapeHtml(title)}</span>
            </div>
            <div class="window-body"></div>
            <div class="resizer"></div>
        `.trim();

        // populate body per type
        const body = wrapper.querySelector('.window-body');
        if (type === 'text') {
            // textarea fills body
            const textarea = document.createElement('textarea');
            textarea.wrap = 'soft';
            textarea.className = 'w-full h-full bg-gray-900/40 text-white resize-none outline-none font-mono p-2';
            textarea.value = opts.content || '';
            // keep textarea relative sizing inside window-body
            textarea.style.boxSizing = 'border-box';
            body.appendChild(textarea);
        } else if (type === 'terminal') {
            // terminal markup similar to cotton/terminal.html — ensure unique ids for input/output
            const outId = `${id}-output`;
            const inId = `${id}-input`;
            body.innerHTML = `
                <div id="${outId}" class="terminal-output" style="font-family: monospace; font-size: 14px; color: #dcdcdc; height: calc(100% - 30px); overflow-y: auto; padding: 6px; background: transparent; border-radius: 4px;">
                    <span id="${outId}-prompt">$ </span>
                </div>
                <input id="${inId}" class="terminal-input" type="text" style="width:100%; padding:6px; font-family:monospace; font-size:14px; color:#dcdcdc; background:transparent; border:none; outline:none;" placeholder="Type a command..." autocomplete="off" />
            `;
        } else {
            // basic placeholder content
            const p = document.createElement('div');
            p.className = 'p-2 text-sm text-[var(--color-text-dark)]';
            p.textContent = opts.content || `App: ${type}`;
            body.appendChild(p);
        }

        return wrapper;
    }

    // register a newly created window element into DWM (attach handlers + make draggable/resizable)
    function registerWindow(winEl, meta = {}) {
        const id = winEl.id;
        if (!id) return;
        windows[id] = {
            el: winEl,
            id,
            type: meta.type || winEl.dataset.app || 'unknown',
            minimized: false,
            maximized: false
        };

        // append into DOM under windows-root
        const root = windowsRoot();
        if (!root) throw new Error('windows-root missing');
        root.appendChild(winEl);

        // bring to front on mousedown (header)
        const header = winEl.querySelector('.window-header');
        header.addEventListener('mousedown', () => bringToFront(winEl));

        // clicks inside window also bring to front
        winEl.addEventListener('mousedown', () => bringToFront(winEl));

        // wire up close/minimize/maximize
        const btnClose = winEl.querySelector('.win-close');
        const btnMin = winEl.querySelector('.win-min');
        const btnMax = winEl.querySelector('.win-max');

        if (btnClose) btnClose.addEventListener('click', (e) => {
            e.stopPropagation();
            closeWindow(id);
        });

        if (btnMin) btnMin.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleMinimize(id);
        });

        if (btnMax) btnMax.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleMaximize(id);
        });

        // wire up resizer + drag via existing function makeDraggableAndResizable
        // makeDraggableAndResizable expects an element id present in DOM
        // call it after element appended to DOM
        if (typeof makeDraggableAndResizable === 'function') {
            makeDraggableAndResizable(id);
        }

        // If terminal, attach simple command handling to its dynamic input
        if (windows[id].type === 'terminal') {
            attachTerminalHandlers(id);
        }

        // focus newly created
        bringToFront(winEl);
        return id;
    }

    // open window by type; if an instance with same friendly name exists, focus it
    function openWindow(type, opts = {}) {
        // If opts.singleton is true, try to find existing window of same type (and title)
        if (opts.singleton) {
            for (const wId in windows) {
                const w = windows[wId];
                if (w.type === type && (!opts.title || w.el.querySelector('.window-title').textContent === opts.title)) {
                    // if minimized — restore
                    if (w.minimized) toggleMinimize(wId);
                    bringToFront(w.el);
                    return wId;
                }
            }
        }

        // create element and register
        const el = createWindowElement(type, opts);
        // set dataset.app for meta
        el.dataset.app = type;
        const newId = registerWindow(el, { type });
        return newId;
    }

    function closeWindow(id) {
        const meta = windows[id];
        if (!meta) return;
        meta.el.remove();
        delete windows[id];
    }

    function toggleMinimize(id) {
        const meta = windows[id];
        if (!meta) return;
        if (!meta.minimized) {
            // hide visually (set display none)
            meta.el.style.display = 'none';
            meta.minimized = true;
        } else {
            meta.el.style.display = 'flex'; // it uses flex column
            meta.minimized = false;
            bringToFront(meta.el);
        }
    }

    function toggleMaximize(id) {
        const meta = windows[id];
        if (!meta) return;
        const el = meta.el;
        if (!meta.maximized) {
            // store previous
            meta.prev = {
                left: el.offsetLeft,
                top: el.offsetTop,
                width: el.offsetWidth,
                height: el.offsetHeight
            };
            el.style.left = '0px';
            el.style.top = '0px';
            el.style.width = `${window.innerWidth}px`;
            el.style.height = `${window.innerHeight - 48}px`; // account for taskbar
            meta.maximized = true;
        } else {
            const p = meta.prev || {};
            el.style.left = (p.left !== undefined ? p.left + 'px' : '120px');
            el.style.top = (p.top !== undefined ? p.top + 'px' : '120px');
            el.style.width = (p.width !== undefined ? p.width + 'px' : '600px');
            el.style.height = (p.height !== undefined ? p.height + 'px' : '380px');
            meta.maximized = false;
        }
        bringToFront(el);
    }

    // attach simple terminal handlers for dynamic terminal windows
    function attachTerminalHandlers(winId) {
        const out = document.getElementById(`${winId}-output`);
        const input = document.getElementById(`${winId}-input`);
        if (!out || !input) return;

        // Utility: append a line (supports html) and auto-scroll
        function appendLine(html, cls) {
            const line = document.createElement('div');
            if (cls) line.className = cls;
            line.innerHTML = html;
            out.appendChild(line);
            out.scrollTop = out.scrollHeight;
            return line;
        }

        // Utility: typing animation for immersive feel
        async function typeOut(el, text, delay=12) {
            el.textContent = '';
            for (let i=0;i<text.length;i++) {
                el.textContent += text[i];
                if (i % 3 === 0) await new Promise(r=>setTimeout(r, delay));
            }
        }

        // Spinner factory
        function makeSpinner(text='working') {
            const spin = document.createElement('div');
            spin.className = 'term-spinner';
            spin.innerHTML = `<span style="color:#888">${text} <span class="pulse-dots">...</span></span>`;
            let dots = 0;
            const interval = setInterval(()=>{
                dots = (dots+1)%4;
                spin.querySelector('.pulse-dots').textContent = '.'.repeat(dots) || '.';
            }, 300);
            spin._stop = ()=>clearInterval(interval);
            return spin;
        }

        // Basic styles injection (once) for terminal feedback if not present
        if (!document.getElementById('terminal-extra-styles')) {
            const style = document.createElement('style');
            style.id = 'terminal-extra-styles';
            style.textContent = `
                .term-success { color: #38c172; }
                .term-error { color: #e3342f; }
                .term-info { color: #6cb2eb; }
                .term-spinner { font-family: monospace; }
            `;
            document.head.appendChild(style);
        }

        input.addEventListener('keydown', e => {
            if (e.key === 'Enter') {
                const cmd = input.value.trim();
                if (!cmd) return;
                appendLine(`<span style="color:#888">$</span> <span>${cmd.replace(/</g,'&lt;')}</span>`);

                // Prompt immediate feedback for known commands
                let responseClass = 'term-info';
                const response = document.createElement('div');
                // Helper for prototype gameplay commands
                async function postStatus(status){
                    if (typeof UPDATE_STATUS_URL === 'undefined' || !UPDATE_STATUS_URL){
                        return { ok:false, message:'Status endpoint unavailable.' };
                    }
                    function getCookie(name){
                        const value = `; ${document.cookie}`;
                        const parts = value.split(`; ${name}=`);
                        if(parts.length === 2) return parts.pop().split(';').shift();
                    }
                    function getCsrfToken(){
                        return getCookie('csrftoken') || (window.CSRF_TOKEN || '') || (document.querySelector('input[name=csrfmiddlewaretoken]')?.value || '');
                    }
                    try {
                        const res = await fetch(UPDATE_STATUS_URL, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': getCsrfToken(),
                                'X-Requested-With': 'XMLHttpRequest'
                            },
                            body: JSON.stringify({ status })
                        });
                        let data = {};
                        try { data = await res.json(); } catch(e){ /* non-JSON */ }
                        if(!res.ok || !data.ok){
                            return { ok:false, message: (data.message || 'Failed to update status.') + ` (HTTP ${res.status})` };
                        }
                        if(data.points_awarded){
                            return { ok:true, message: (data.message || 'Completed.') + ` Awarded: +${data.points_awarded}` };
                        }
                        return { ok:true, message: data.message || 'Status updated.' };
                    }catch(err){
                        return { ok:false, message:'Error contacting server.' };
                    }
                }

                if (cmd === 'help') response.textContent = 'Available: help, clear, echo [text], /inprogress, /complete, /status';
                else if (cmd === 'clear') {
                    out.innerHTML = `<span id="${winId}-output-prompt">$ </span>`;
                    input.value = '';
                    return;
                } else if (cmd.startsWith('echo ')) response.textContent = cmd.slice(5);
                else if (cmd === '/inprogress') {
                    response.textContent = 'Requesting status: In Progress';
                    const spinner = makeSpinner('updating');
                    out.appendChild(spinner);
                    postStatus('in_progress').then(resObj => {
                        spinner._stop();
                        spinner.remove();
                        const follow = document.createElement('div');
                        follow.className = resObj.ok ? 'term-success' : 'term-error';
                        typeOut(follow, resObj.message);
                        out.appendChild(follow);
                        out.scrollTop = out.scrollHeight;
                    });
                }
                else if (cmd === '/complete') {
                    response.textContent = 'Submitting completion...';
                    const spinner = makeSpinner('completing');
                    out.appendChild(spinner);
                    postStatus('completed').then(resObj => {
                        spinner._stop();
                        spinner.remove();
                        const follow = document.createElement('div');
                        follow.className = resObj.ok ? 'term-success' : 'term-error';
                        typeOut(follow, resObj.message);
                        out.appendChild(follow);
                        out.scrollTop = out.scrollHeight;
                    });
                }
                else if (cmd === '/status') {
                    response.textContent = 'Status commands: /inprogress, /complete';
                }
                else response.textContent = `${cmd}: command not found`;

                out.appendChild(response);
                out.scrollTop = out.scrollHeight;
                input.value = '';
            }
        });
    }

    // small utility to escape HTML when inserting titles
    function escapeHtml(s) {
        if (s === undefined || s === null) return '';
        return String(s).replace(/[&<>"']/g, function(m) {
            return ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            })[m];
        });
    }

    // allow access to window list for tests or UI
    function listWindows() {
        return Object.keys(windows);
    }

    // register existing .c-window elements already in DOM (optional)
    function registerExisting() {
        document.querySelectorAll('.c-window').forEach(el => {
            if (!el.id) el.id = genId('win');
            // Avoid double-registering if this script created it
            if (!windows[el.id]) {
                // attempt to detect terminal by presence of .terminal-input
                const type = el.querySelector('.terminal-input') ? 'terminal' : (el.querySelector('textarea') ? 'text' : (el.dataset.app || 'window'));
                el.dataset.app = type;
                registerWindow(el, { type });
            }
        });
    }

    // public API
    return {
        openWindow,
        closeWindow,
        toggleMinimize,
        toggleMaximize,
        bringToFront,
        listWindows,
        registerExisting
    };
})();

/* =======================================================
   DRAG + RESIZE SYSTEM (kept from your previous file,
   slightly adapted so it works with elements created dynamically)
   ======================================================= */
function makeDraggableAndResizable(winId) {
    const win = document.getElementById(winId);
    if (!win) return;
    const header = win.querySelector(".window-header");
    const resizer = win.querySelector(".resizer");

    let dragging = false;
    let resizing = false;

    let offsetX, offsetY;
    let startW, startH, startX, startY;

    const MIN_W = 260;
    const MIN_H = 140;

    /* DRAG */
    header.addEventListener("mousedown", e => {
        if (e.target.closest(".win-btn")) return;

        dragging = true;
        offsetX = e.clientX - win.offsetLeft;
        offsetY = e.clientY - win.offsetTop;

        // bring to front
        win.style.zIndex = (parseInt(win.style.zIndex) || 100) + 1000;

        e.preventDefault();
    });

    /* RESIZE */
    resizer.addEventListener("mousedown", e => {
        resizing = true;
        startW = win.offsetWidth;
        startH = win.offsetHeight;
        startX = e.clientX;
        startY = e.clientY;
        e.stopPropagation();
        e.preventDefault();
    });

    document.addEventListener("mousemove", e => {
        if (dragging) {
            let left = e.clientX - offsetX;
            let top = e.clientY - offsetY;

            left = Math.max(0, Math.min(left, window.innerWidth - win.offsetWidth));
            top = Math.max(0, Math.min(top, window.innerHeight - win.offsetHeight - 48));

            win.style.left = `${left}px`;
            win.style.top = `${top}px`;
        }

        if (resizing) {
            let width = startW + (e.clientX - startX);
            let height = startH + (e.clientY - startY);

            width = Math.max(MIN_W, width);
            height = Math.max(MIN_H, height);

            const rect = win.getBoundingClientRect();
            width = Math.min(width, window.innerWidth - rect.left);
            height = Math.min(height, window.innerHeight - rect.top - 20);

            win.style.width = `${width}px`;
            win.style.height = `${height}px`;
        }
    });

    document.addEventListener("mouseup", () => {
        dragging = false;
        resizing = false;
    });
}

/* =======================================================
   Power menu, dropdowns, and misc page logic (kept mostly)
   ======================================================= */
document.addEventListener("DOMContentLoaded", () => {
    // power dropdown logic (unchanged)
    const powerBtn = document.getElementById("power-btn");
    const powerDropdown = document.getElementById("power-dropdown");
    if (powerBtn && powerDropdown) {
        powerBtn.addEventListener("click", e => {
            e.stopPropagation();
            powerDropdown.classList.toggle("dropdown-hidden");
            const rect = powerBtn.getBoundingClientRect();
            const dropdownHeight = powerDropdown.offsetHeight;
            const margin = 6;
            powerDropdown.style.top = `${window.innerHeight - rect.bottom - dropdownHeight - margin}px`;
            powerDropdown.style.left = `${rect.left}px`;
        });

        document.addEventListener("click", e => {
            if (!powerDropdown.contains(e.target) && !powerBtn.contains(e.target)) {
                powerDropdown.classList.add("dropdown-hidden");
            }
        });

        powerDropdown.querySelectorAll("button").forEach(btn => {
            btn.addEventListener("click", () => {
                const url = btn.getAttribute("data-url");
                const action = btn.getAttribute("data-action");
                if (url) window.location.href = url;
                else if (action === "restart") alert("Restart feature to be implemented");
                powerDropdown.classList.add("dropdown-hidden");
            });
        });
    }

    // register existing windows if any (for backwards compatibility)
    DWM.registerExisting();

    // wire taskbar icons to spawn/focus windows
    document.querySelectorAll('.taskbar-center .taskbar-icon').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const app = btn.dataset.app;
            if (!app) return;

            // if readonly, prevent launching problematic apps
            if (IS_READONLY && app === 'terminal') {
                alert('Terminal disabled in read-only mode.');
                return;
            }

            if (app === 'text') {
                DWM.openWindow('text', { singleton: true, title: 'Welcome.txt', content: INITIAL_TEXT });
            } else if (app === 'terminal') {
                DWM.openWindow('terminal', { singleton: true, title: 'Terminal' });
            } else {
                // placeholder apps open a simple window
                DWM.openWindow('app-' + app, { title: app });
            }
        });
    });

    /* PROGRESS SAVE (resume + unsaved warning support) - kept from previous code */
    const area = document.querySelector('.desktop-area');
    if (area) {
        const readonly = area.getAttribute('data-readonly') === 'true';
        const saveUrl = area.getAttribute('data-save-url');
        if(!readonly && saveUrl) {
            function getCookie(name){
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if(parts.length === 2) return parts.pop().split(';').shift();
            }
            function collectState(){
                const editor = document.querySelector('#welcome-editor textarea');
                const text = editor ? editor.value : null;
                return { text };
            }
            async function saveOnce(){
                try{
                    const body = JSON.stringify({ last_state: collectState() });
                    await fetch(saveUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCookie('csrftoken'),
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body
                    });
                }catch(e){
                    // ignore
                }
            }
            setTimeout(saveOnce, 1500);
            const interval = setInterval(saveOnce, 15000);
            window.addEventListener('beforeunload', () => {
                clearInterval(interval);
                if(navigator.sendBeacon){
                    const data = new Blob([JSON.stringify({ last_state: collectState() })], {type:'application/json'});
                    navigator.sendBeacon(saveUrl, data);
                }else{
                    saveOnce();
                }
            });
        }
    }
});

document.addEventListener("challenge-ready", () => {
    // Spawn initial text document if provided
    if (INITIAL_TEXT && INITIAL_TEXT.trim() !== "") {
        DWM.openWindow('text', { singleton: true, title: 'Welcome.txt', content: INITIAL_TEXT });
        // Auto-open terminal for convenience
        if (!IS_READONLY) {
            DWM.openWindow('terminal', { singleton: true, title: 'Terminal' });
        }
    }
});
